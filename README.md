# prj_gen

`prj_gen` is a generalized template based project scaffolding generation library
written in python. Tha library provides an abstract class called `Gen` that
handles the functionality. The library users will write class derived from `Gen`
that implements the virtual functions to customize for their specific CLI that
they will implement.

## Template layout
```
template
   +-- prj (folder)
   +-- prj.toml
```
The `prj.toml` file will be used to get user input which will generate a *context*
for the templates. `prj` is a project folder containing templates that will be
used for scaffolding. 

## Project folder layout
```
project
   +-- folderA
   |     +-- template_fileA
   |     +-- template_fileB
   |         ...
   +-- folderB
   |     +-- template_fileC
   |     +-- template_fileD
   |         ...
   |   ...
   +-- template_fileE
   +-- template_fileF
   |   ...
```
Each folder can have more nested folders having same structure.

## Template handling
The *context* we built using `prj.toml` will simply is a python dictionary. It
has pairs *key* and *value*. We use `jinja` template engine. When `jinja` gets a
template it will search the template for occurrences of `{{ some_text }}`
pattern. When it finds one and `some_text` matches a *key*, it simply substitute
the pattern with *value*.

We apply this substitution process to file contents. We also also apply
substitution to file and folder names. Then each folder creates a folder in the
generated scaffolding and a file creates a file keeping the scaffolding
structure exactly same as the project folder.

`jinja` is a powerful template engine. It has many more capabilities, you can do
much more with it. Read it's [documentation](https://jinja.palletsprojects.com/).

## List of projects

More complex situation may require different scaffolding structure under
different situation. In such case multiple projects are to be used.

Template layout
```
template
   +-- projectA
   +-- projectB
   +-- projectC
   |   ...
   +-- prj.toml
```
The project is actually selected by a class function called `select_project`.
The default version selects the project named `prj` which is how it worked for
the single project case.

Note that the projects are not nested in the layout, they are in the same folder
level. They just provide different group of templates organized by functional
tasks.

However, in this multiple project case, an override of `select_project` can
select a project or multiple projects by examining the context and returning a
list of project names. The template processing will be done for each project in
the same order they appear in the list. This provides a very structured
multi-pass generation to provide a rich set of combinations of functionality yet
still maintaining functional separation of templates. 

## Special template file

If a template file name looks like `{#filename.ext#}.toml` pattern then file
content will be parsed as toml into a python dictionary and a class function
called `special_content` will be called to process the dictionary. This function
will return some content generated by using the dictionary and the content will
be written as a file named `filenamee.ext`.

The default `special_content` will raise a NotImplementedError exception. You
need to override it to add special template handling based on your specific
requirements.